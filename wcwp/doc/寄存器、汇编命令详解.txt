16bit
[汇编]寄存器说明
1．通用寄存器
　　通用寄存器包括了8个16位的寄存器：AX、BX、CX、DX、SP、BP、DI及SI。其中AX、BX、CX、DX在一般情况下作为通用的数据寄存器，用来暂时存放计算过程中所用到的操作数、结果或其他信息。它们还可分为两个独立的8位寄存器使用，命名为AL、AH、BL、BH、CL、CH、DL和DH。这4个通用数据寄存器除通用功能外，还有如下专门用途：

　　AX作为累加器用，所以它是算术运算的主要寄存器。在乘除指令中指定用来存放操作数。另外，所有的I/O指令都使用AX或AL与外部设备传送信息。

　　BX在计算存储器地址时，可作为基址寄存器使用。

　　CX常用来保存计数值，如在移位指令、循环指令和串处理指令中用作隐含的计数器。
DX在作双字长运算时，可把DX和AX组合在一起存放一个双字长数，DX用来存放高16位数据。此外，对某些I/O操作，DX可用来存放I/O的端口地址。

　　SP、BP、SI、DI四个16位寄存器可以象数据寄存器一样在运算过程中存放操作数，但它们只能以字（16位）为单位使用。此外，它们更经常的用途是在存储器寻址时，提供偏移地址。因此，它们可称为指针或变址寄存器。

　　SP称为堆栈指针寄存器，用来指出栈顶的偏移地址。

　　BP称为基址指针寄存器，在寻址时作为基地址寄存器使用，但它必须与堆栈段寄存器SS联用来确定堆栈段中的存储单元地址。

　　SI为源变址寄存器，在串处理指令中，SI作为隐含的源变址寄存器与DS联用，以确定数据段中的存储单元地址，并有自动增量和自动减量的变址功能。

　　DI为目的变址寄存器，在串处理指令中，DI和附加段寄存器ES联用，以达到在附加段中寻址的目的，然后DI自动增量或减量。

2． 专用寄存器

　　8086的专用寄存器包括IP、SP和FLAGS三个16位寄存器。

　　IP为指令指针寄存器，它用来存放将要执行的下一条指令地址的偏移量，它与段寄存器CS联合形成代码段中指令的物理地址。在计算机中，控制程序的执行流程就是通过控制IP的值来实现的。

　　SP为堆栈指针寄存器，它与堆栈段寄存器联用来确定堆栈段中栈顶的地址，也就是说SP用来存放栈顶的偏移地址。

　　FLAGS为标志寄存器，这是一个存放条件码标志、控制标志的16位寄存器。

[　　条件码标志用来记录程序中运行结果的状态信息，它们是根据有关指令的运行结果由CPU自动设置的。由于这些状态信息往往作为后续条件转移指令的转移控制条件，所以称为条件码。
　　① 进位标志　CF，记录运算时最高有效位产生的进位值。
　　② 符号标志　SF，记录运算结果的符号。结果为负时置1，否则置0。
　　③ 零标志　　ZF，运算结果为0时ZF位置1，否则置0。
　　④ 溢出标志　OF，在运算过程中，如操作数超出了机器可表示数的范围称为溢出。溢出时OF位置1，否则置0。
　　⑤ 辅助进位标志　AF，记录运算时第3位（半个字节）产生的进位值。
　　⑥ 奇偶标志　PF，用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中1的个数为偶数时置1，否则置0。


　　控制标志位有3位：
　　① 方向标志　DF，在串处理指令中控制处理信息的方向。当DF=1时，串处理从高地址向低地址方向处理。当DF=0时，串处理就从低地址向高地址方向处理。
　　② 陷阱标志　TF，用于调试时的单步方式操作。当TF=1时，每条指令执行完后产生陷阱，由系统控制计算机；当TF=0时，CPU正常工作，不产生陷阱。
　　③ 中断标志　IF，用于控制可屏蔽硬件中断。当IF=1时，允许8086微处理器响应中断请求，否则关闭中断。

　　8086提供了设置某些状态信息的指令。必要时，程序员可使用这些指令来建立状态信息。]

3． 段寄存器　　

　　8086微处理器共有4个16位的段寄存器，在寻址内存单元时，用它们直接或间接地存放段地址。
　　代码段寄存器CS：存放当前执行的程序的段地址。
　　数据段寄存器DS：存放当前执行的程序所用操作数的段地址。
　　堆栈段寄存器SS：存放当前执行的程序所用堆栈的段地址。
　　附加段寄存器ES：存放当前执行程序中一个辅助数据段的段地址。


32bit
汇编命令详解

32位CPU所含有的寄存器有：
4个数据寄存器(EAX、EBX、ECX和EDX)
2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP) 
6个段寄存器(ES、CS、SS、DS、FS和GS)
1个指令指针寄存器(EIP) 1个标志寄存器(EFlags) 

1、数据寄存器
数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。
32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。
对低16位数据的存取，不会影响高16位的数据。
这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。
4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。
程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。

寄存器EAX通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。可用于乘、 除、输入/输出等操作，使用频率很高；

寄存器EBX称为基地址寄存器(Base Register)。它可作为存储器指针来使用； 

寄存器ECX称为计数寄存器(Count Register)。

在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；

寄存器EDX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。 
在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，
在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，
而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。

2、变址寄存器
32位CPU有2个32位通用寄存器ESI和EDI。
其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。
寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，
用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。
变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。
它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。

3、指针寄存器
其低16位对应先前CPU中的BP和SP，对低16位数据的存取，不影响高16位的数据。
32位CPU有2个32位通用寄存器EBP和ESP。
它们主要用于访问堆栈内的存储单元，并且规定：
EBP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据； 
ESP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。 
寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，
用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。
指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。

4、段寄存器
段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成
的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。
CPU内部的段寄存器：
ECS――代码段寄存器(Code Segment Register)，其值为代码段的段值； 
EDS――数据段寄存器(Data Segment Register)，其值为数据段的段值； 
EES――附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； 
ESS――堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值； 
EFS――附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； 
EGS――附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。 
在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位
微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。
32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简
单描述如下：
实方式： 前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑
地址仍为“段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。 
保护方式： 在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”(Selector)的某个值。。 

5、指令指针寄存器
32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。
指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。
在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。
所以，在理解它们的功能时，不考虑存在指令队列的情况。

6、标志寄存器


一、运算结果标志位

1、进位标志CF(Carry Flag)
进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。
使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。
2、奇偶标志PF(Parity Flag)
奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。
利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。
3、辅助进位标志AF(Auxiliary Carry Flag)
在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：
(1)、在字操作时，发生低字节向高字节进位或借位时；
(2)、在字节操作时，发生低4位向高4位进位或借位时。
对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。
4、零标志ZF(Zero Flag)
零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。
5、符号标志SF(Sign Flag)
符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。
6、溢出标志OF(Overflow Flag)
溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。
“溢出”和“进位”是两个不同含义的概念，不要混淆。如果不太清楚的话，请查阅《计算机组成原理》课程中的有关章节。


二、状态控制标志位
状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。
1、追踪标志TF(Trap Flag)
当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。
指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。
2、中断允许标志IF(Interrupt-enable Flag)
中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。
但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。
具体规定如下：
(1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；
(2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。
CPU的指令系统中也有专门的指令来改变标志位IF的值。
3、方向标志DF(Direction Flag)
方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节――字符串操作指令――中给出。
在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。
三、32位标志寄存器增加的标志位
1、I/O特权标志IOPL(I/O Privilege Level)
I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。
如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。
2、嵌套任务标志NT(Nested Task)
嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：
(1)、当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；
(2)、当NT=1，通过任务转换实现中断返回。
3、重启动标志RF(Restart Flag)
重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。
在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。
4、虚拟8086方式标志VM(Virtual 8086 Mode)
如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。





计算机寄存器常用指令

一、常用指令  
1. 通用数据传送指令.  
   MOV 传送字或字节.  
   MOVSX 先符号扩展,再传送.  
   MOVZX 先零扩展,再传送.  
   PUSH 把字压入堆栈.  
   POP 把字弹出堆栈.  
   PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.  
   POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.  
   PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.  
   POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.  
   BSWAP 交换32位寄存器里字节的顺序  
   XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)  
   CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )  
   XADD 先交换再累加.( 结果在第一个操作数里 )  
   XLAT 字节查表转换.  
   BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]->AL )  

2. 输入输出端口传送指令.  
   IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} )  
   OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )  
   输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535.  

3. 目的地址传送指令.  
   LEA 装入有效地址.  
     例: LEA DX,string ;把偏移地址存到DX.  
   LDS 传送目标指针,把指针内容装入DS.  
     例: LDS SI,string ;把段地址:偏移地址存到DS:SI.  
   LES 传送目标指针,把指针内容装入ES.  
     例: LES DI,string ;把段地址:偏移地址存到ESDI.  
   LFS 传送目标指针,把指针内容装入FS.  
     例: LFS DI,string ;把段地址:偏移地址存到FSD.  
   LGS 传送目标指针,把指针内容装入GS.  
     例: LGS DI,string ;把段地址:偏移地址存到GSDI.  
   LSS 传送目标指针,把指针内容装入SS.  
     例: LSS DI,string ;把段地址:偏移地址存到SSDI.  

4. 标志传送指令.  
   LAHF 标志寄存器传送,把标志装入AH.  
   SAHF 标志寄存器传送,把AH内容装入标志寄存器.  
   PUSHF 标志入栈.  
   POPF 标志出栈.  
   PUSHD 32位标志入栈.  
   POPD 32位标志出栈.


二、算术运算指令  
   ADD 加法.  
   ADC 带进位加法.  
   INC 加 1.  
   AAA 加法的ASCII码调整.  
   DAA 加法的十进制调整.  
   SUB 减法.  
   SBB 带借位减法.  
   DEC 减 1.  
   NEC 求反(以 0 减之).  
   CMP 比较.(两操作数作减法,仅修改标志位,不回送结果).  
   AAS 减法的ASCII码调整.  
   DAS 减法的十进制调整.  
   MUL 无符号乘法.  
   IMUL 整数乘法.  
     以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),  
   AAM 乘法的ASCII码调整.  
   DIV 无符号除法.  
   IDIV 整数除法.  
     以上两条,结果回送:  
     商回送AL,余数回送AH, (字节运算);  
     或 商回送AX,余数回送DX, (字运算).  
   AAD 除法的ASCII码调整.  
   CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)  
   CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)
   CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)  
   CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) 


三、逻辑运算指令  
   AND 与运算.  
   OR 或运算.  
   XOR 异或运算.  
   NOT 取反.  
   TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).  
   SHL 逻辑左移.  
   SAL 算术左移.(=SHL)  
   SHR 逻辑右移.  
   SAR 算术右移.(=SHR)  
   ROL 循环左移.  
   ROR 循环右移.  
   RCL 通过进位的循环左移.  
   RCR 通过进位的循环右移.  
     以上八种移位指令,其移位次数可达255次.  
     移位一次时, 可直接用操作码. 如 SHL AX,1.  
     移位>1次时, 则由寄存器CL给出移位次数.  
      如 MOV CL,04  
         SHL AX,CL  


四、串指令  
   DS:SI 源串段寄存器 :源串变址.  
   ES I 目标串段寄存器:目标串变址.  
   CX 重复次数计数器.  
   AL/AX 扫描值.  
   D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.  
   Z标志 用来控制扫描或比较操作的结束.  
   MOVS 串传送.  
   ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )  
   CMPS 串比较.  
   ( CMPSB 比较字符. CMPSW 比较字. )  
   SCAS 串扫描.  
     把AL或AX的内容与目标串作比较,比较结果反映在标志位.  
   LODS 装入串.  
     把源串中的元素(字或字节)逐一装入AL或AX中.  
   ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )  
   STOS 保存串.  
   是LODS的逆过程.  
   REP 当CX/ECX0时重复.  
   REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX0时重复.  
   REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX0时重复.  
   REPC 当CF=1且CX/ECX0时重复.  
   REPNC 当CF=0且CX/ECX0时重复.  


五、程序转移指令  
1.简单的条件转移指令 
JZ(或jE)    OPR---------------结果为零转移,  测试条件ZF=1 
JNZ(或jNE)  OPR --------------结果不为零转移,测试条件ZF=0 
JS   OPR----------------------结果为负转移,  测试条件SF=1 
JNS   OPR---------------------结果为正转移,  测试条件SF=0 
JO   OPR--------------------- 溢出转移,      测试条件OF= 
JNO   OPR --------------------不溢出转移 ,   测试条件SF=0 
JP   OPR ---------------------结果为偶转移,  测试条件SF=1 
JNP   OPR --------------------结果为奇转移 , 测试条件SF=0 
JC   OPR -------------------- 有进位转移 ,   测试条件SF=1 
JNC   OPR --------------------无进位转移,    测试条件SF=0 
2.无符号比较条件转移指令(以下指令经常是CMP OPD,OPS后面的指令根据比较结果来实现转移) 
JB(或JNAE) opd --------------小于或者不大于等于则转移 
JNB(或JAE) opd---------------不小于或者大于等于则转移 
JA(或NJBE) OPD---------------大于或者不小于等于则转移 
JNA(或JBE) OPD---------------不大于或者小于等于则转移 
3.带符号比较条件转移指令 
JL(或JNGE) --------------小于或者不大于等于则转移 
JNL(或JGE)--------------不小于或者大于等于则转移 
JG(或NJLE)---------------大于或者不小于等于则转移 
JNG(或JLE)---------------不大于或者小于等于则转移 
六、调用子程序与返回指令 
CALL     子程序调用指令 
RET   子程序返回指令 


六、其它指令 
OFFSET   -------------------- 返回偏移地址 
SEG     -------------------- 返回段地址 
EQU(=)  --------------------  等值语句 
PURGE  --------------------  解除语句 
DUP    --------------------  操作数字段用复制操作符 
SEGMENT,ENDS  --------------------  段定义指令 
ASSUME   -------------------- 段地址分配指令 
ORG    --------------------  起始偏移地址设置指令 
$      --------------------地址计数器的当前值 
PROC，ENDP  --------------------  过程定义语句 
NAME，TITLE，END  --------------------  程序开始结束语句 
MACRO，ENDM    --------------------宏定义指令 
XLAT    （TRANSLATE） --------------------   换码指令---- 


七、条件标志 
ZF 零标志 -- 当结果为负时,SF=1,否则,SF=0. 
AF 辅助进位标志---运算过程中第三位有进位值,置AF=1,否则,AF=0 
PF 奇偶标志------当结果操作数中偶数个"1",置PF=1,否则,PF=0 
SF  符号标志----当结果为负时,SF=1;否则,SF=0.溢出时情形例外 
CF 进位标志----- 最高有效位产生进位值,例如,执行加法指令时,MSB有进位,置CF=1;否则,CF=0. 
OF 溢出标志-----若操作数结果超出了机器能表示的范围,则产生溢出,置OF=1,否则,OF=0 
